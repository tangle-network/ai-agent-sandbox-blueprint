#!/usr/bin/env bash
# test-e2e.sh — Full end-to-end integration tests against a running local stack.
#
# Exercises: on-chain state, operator API, session auth, sandbox lifecycle,
# instance lifecycle, and error cases. Requires a running local stack
# (deploy-local.sh) with Anvil, operator, and Docker.
#
# Usage:
#   # First, start the stack:
#   SKIP_BUILD=1 ./scripts/deploy-local.sh
#
#   # Then run e2e tests:
#   ./scripts/test-e2e.sh
#
# Environment overrides:
#   E2E_TIMEOUT     — Per-operation timeout in seconds (default: 180)
#   SKIP_LIFECYCLE  — Set to 1 to skip sandbox/instance lifecycle (faster)
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# ─────────────────────────────────────────────────────────────────────────────
# Load environment from .env.local (generated by deploy-local.sh)
# ─────────────────────────────────────────────────────────────────────────────

ENV_FILE="$ROOT_DIR/.env.local"
if [ ! -f "$ENV_FILE" ]; then
    echo "ERROR: $ENV_FILE not found. Run deploy-local.sh first."
    exit 1
fi
set -o allexport
source "$ENV_FILE"
set +o allexport

RPC_URL="${HTTP_RPC_ENDPOINT:-http://127.0.0.1:8645}"
TANGLE="${TANGLE_CONTRACT}"
API_URL="http://127.0.0.1:${OPERATOR_API_PORT:-9100}"
TIMEOUT="${E2E_TIMEOUT:-180}"

# ─────────────────────────────────────────────────────────────────────────────
# Test framework
# ─────────────────────────────────────────────────────────────────────────────

PASS=0; FAIL=0; SKIP=0; TOTAL=0; START_TIME=$(date +%s)
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; CYAN='\033[0;36m'; NC='\033[0m'

pass() { PASS=$((PASS+1)); TOTAL=$((TOTAL+1)); echo -e "  ${GREEN}PASS${NC} $1"; }
fail() { FAIL=$((FAIL+1)); TOTAL=$((TOTAL+1)); echo -e "  ${RED}FAIL${NC} $1"; }
skip() { SKIP=$((SKIP+1)); TOTAL=$((TOTAL+1)); echo -e "  ${YELLOW}SKIP${NC} $1"; }

assert_eq() {
    local got="$1" expected="$2" desc="$3"
    if [ "$got" = "$expected" ]; then pass "$desc"; else fail "$desc (expected='$expected', got='$got')"; fi
}
assert_ne() {
    local got="$1" not_expected="$2" desc="$3"
    if [ "$got" != "$not_expected" ]; then pass "$desc"; else fail "$desc (got unexpected '$got')"; fi
}
assert_contains() {
    local haystack="$1" needle="$2" desc="$3"
    if echo "$haystack" | grep -q "$needle"; then pass "$desc"; else fail "$desc (missing '$needle')"; fi
}
assert_http() {
    local code="$1" expected="$2" desc="$3"
    if [ "$code" = "$expected" ]; then pass "$desc (HTTP $code)"; else fail "$desc (expected HTTP $expected, got $code)"; fi
}
assert_reverts() {
    local output="$1" desc="$2"
    if echo "$output" | grep -qi "revert\|execution reverted"; then
        pass "$desc (reverted as expected)"
    else
        fail "$desc (expected revert, got: ${output:0:100})"
    fi
}

section() { echo -e "\n${CYAN}[$1]${NC} $2"; }

# Submit a job and return the call_id (uses static call for return value, then send).
# Usage: submit_job <service_id> <job_id> <abi_args> <value> <private_key>
submit_job() {
    local svc="$1" job="$2" args="$3" value="${4:-0}" key="${5:-$USER_KEY}"
    local from_addr
    from_addr=$(cast wallet address --private-key "$key" 2>/dev/null)

    # Static call to get the return value (call_id)
    local call_id
    call_id=$(cast call "$TANGLE" \
        "submitJob(uint64,uint8,bytes)(uint64)" \
        "$svc" "$job" "$args" \
        --from "$from_addr" --rpc-url "$RPC_URL" --value "$value" 2>/dev/null) || {
        echo "REVERT"
        return 1
    }
    # strip cast label (e.g. "42 [4.2e1]" → "42")
    call_id=$(echo "$call_id" | awk '{print $1}')

    # Actually send the transaction
    cast send "$TANGLE" \
        "submitJob(uint64,uint8,bytes)" \
        "$svc" "$job" "$args" \
        --private-key "$key" --rpc-url "$RPC_URL" \
        --value "$value" --gas-limit 5000000 \
        --json > /dev/null 2>&1 || {
        echo "TX_FAIL"
        return 1
    }

    echo "$call_id"
}

# Poll operator API until provision reaches target phase or timeout.
# Usage: poll_provision <call_id> <target_phase> <timeout_secs>
poll_provision() {
    local call_id="$1" target="$2" timeout="${3:-$TIMEOUT}"
    local deadline=$((SECONDS + timeout))
    while [ $SECONDS -lt $deadline ]; do
        local resp
        resp=$(curl -s "$API_URL/api/provisions/$call_id" 2>/dev/null) || true
        local phase
        phase=$(echo "$resp" | jq -r '.phase // empty' 2>/dev/null) || true
        case "$phase" in
            "$target") echo "$resp"; return 0 ;;
            failed)
                local msg
                msg=$(echo "$resp" | jq -r '.message // "unknown"' 2>/dev/null)
                echo "FAILED:$msg"
                return 1 ;;
        esac
        sleep 3
    done
    echo "TIMEOUT"
    return 1
}

# Get job event rate from Tangle for a blueprint + job index.
# Usage: get_job_rate <blueprint_id> <job_id>
get_job_rate() {
    local bp_id="$1" job_id="$2"
    local raw
    raw=$(cast call "$TANGLE" "getJobEventRate(uint64,uint8)(uint256)" "$bp_id" "$job_id" --rpc-url "$RPC_URL" 2>/dev/null) || { echo "0"; return; }
    # cast returns "1000000000000000 [1e15]" — strip the label
    echo "$raw" | awk '{print $1}'
}

# ═════════════════════════════════════════════════════════════════════════════
# Section 0: Prerequisites
# ═════════════════════════════════════════════════════════════════════════════

section "0" "Prerequisites"

# Check tools
for cmd in cast curl jq; do
    if command -v "$cmd" &>/dev/null; then
        pass "$cmd available"
    else
        fail "$cmd not found"
        echo "Install $cmd and try again."
        exit 1
    fi
done

# Check Anvil
BLOCK=$(cast block-number --rpc-url "$RPC_URL" 2>/dev/null || echo "UNREACHABLE")
if [ "$BLOCK" != "UNREACHABLE" ] && [ "$BLOCK" -gt 0 ] 2>/dev/null; then
    pass "Anvil running at $RPC_URL (block $BLOCK)"
else
    fail "Anvil not reachable at $RPC_URL"
    exit 1
fi

# Check operator API
API_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/provisions" 2>/dev/null || echo "000")
if [ "$API_CODE" = "200" ]; then
    pass "Operator API running at $API_URL"
else
    fail "Operator API not reachable at $API_URL (HTTP $API_CODE)"
    exit 1
fi

# Verify environment vars
for var in TANGLE_CONTRACT SANDBOX_BSM INSTANCE_BSM SANDBOX_SERVICE_ID INSTANCE_SERVICE_ID USER_KEY USER_ADDR DEPLOYER_KEY; do
    if [ -n "${!var:-}" ]; then
        pass "\$$var set"
    else
        fail "\$$var not set in .env.local"
    fi
done

# ═════════════════════════════════════════════════════════════════════════════
# Section 1: On-Chain State Validation
# ═════════════════════════════════════════════════════════════════════════════

section "1" "On-Chain State Validation"

# Verify sandbox BSM is accessible
SANDBOX_JOB_COUNT=$(cast call "$SANDBOX_BSM" "jobCount()(uint256)" --rpc-url "$RPC_URL" 2>/dev/null || echo "0")
if [ "$SANDBOX_JOB_COUNT" -ge 17 ] 2>/dev/null; then
    pass "Sandbox BSM has $SANDBOX_JOB_COUNT jobs (expected >=17)"
else
    fail "Sandbox BSM jobCount=$SANDBOX_JOB_COUNT (expected >=17)"
fi

# Verify instance BSM is accessible
INSTANCE_JOB_COUNT=$(cast call "$INSTANCE_BSM" "jobCount()(uint256)" --rpc-url "$RPC_URL" 2>/dev/null || echo "0")
if [ "$INSTANCE_JOB_COUNT" -ge 8 ] 2>/dev/null; then
    pass "Instance BSM has $INSTANCE_JOB_COUNT jobs (expected >=8)"
else
    fail "Instance BSM jobCount=$INSTANCE_JOB_COUNT (expected >=8)"
fi

# Verify operators have capacity on sandbox BSM
OP1_CAP=$(cast call "$SANDBOX_BSM" "operatorMaxCapacity(address)(uint32)" "$OPERATOR1_ADDR" --rpc-url "$RPC_URL" 2>/dev/null || echo "0")
if [ "$OP1_CAP" -gt 0 ] 2>/dev/null; then
    pass "Operator 1 has capacity=$OP1_CAP on sandbox BSM"
else
    fail "Operator 1 has no capacity on sandbox BSM (got $OP1_CAP)"
fi

# Verify sandbox service is active
SANDBOX_SVC_ACTIVE=$(cast call "$TANGLE" "isServiceActive(uint64)(bool)" "$SANDBOX_SERVICE_ID" --rpc-url "$RPC_URL" 2>/dev/null || echo "false")
assert_eq "$SANDBOX_SVC_ACTIVE" "true" "Sandbox service #$SANDBOX_SERVICE_ID is active"

# Verify instance service is active
INSTANCE_SVC_ACTIVE=$(cast call "$TANGLE" "isServiceActive(uint64)(bool)" "$INSTANCE_SERVICE_ID" --rpc-url "$RPC_URL" 2>/dev/null || echo "false")
assert_eq "$INSTANCE_SVC_ACTIVE" "true" "Instance service #$INSTANCE_SERVICE_ID is active"

# Verify service-to-blueprint mapping (catches deploy-local.sh service ID bugs)
SANDBOX_SVC_DATA=$(cast call "$TANGLE" "getService(uint64)" "$SANDBOX_SERVICE_ID" --rpc-url "$RPC_URL" 2>/dev/null)
SANDBOX_SVC_BPID=$(echo "$SANDBOX_SVC_DATA" | head -c 66 | sed 's/^0x0*//' | sed 's/^$/0/')
assert_eq "$SANDBOX_SVC_BPID" "$SANDBOX_BLUEPRINT_ID" "Sandbox service maps to blueprint #$SANDBOX_BLUEPRINT_ID"

# Verify user is permitted caller on sandbox service
USER_PERMITTED=$(cast call "$TANGLE" "isPermittedCaller(uint64,address)(bool)" "$SANDBOX_SERVICE_ID" "$USER_ADDR" --rpc-url "$RPC_URL" 2>/dev/null || echo "false")
assert_eq "$USER_PERMITTED" "true" "User is permitted caller on sandbox service"

# Error case: nonexistent service
BAD_SVC_RESULT=$(cast call "$TANGLE" "isServiceActive(uint64)(bool)" 999 --rpc-url "$RPC_URL" 2>/dev/null || echo "false")
assert_eq "$BAD_SVC_RESULT" "false" "Service 999 is not active"

# Error case: submitJob to nonexistent service should revert
BAD_SUBMIT=$(cast call "$TANGLE" \
    "submitJob(uint64,uint8,bytes)(uint64)" \
    999 0 "0x" \
    --from "$USER_ADDR" --rpc-url "$RPC_URL" 2>&1 || true)
assert_reverts "$BAD_SUBMIT" "submitJob(svc=999) reverts"

# ═════════════════════════════════════════════════════════════════════════════
# Section 2: Operator API Basics
# ═════════════════════════════════════════════════════════════════════════════

section "2" "Operator API"

# Provisions endpoint
PROV_RESP=$(curl -s "$API_URL/api/provisions")
PROV_COUNT=$(echo "$PROV_RESP" | jq '.provisions | length' 2>/dev/null || echo "-1")
if [ "$PROV_COUNT" -ge 0 ] 2>/dev/null; then
    pass "GET /api/provisions ($PROV_COUNT provisions)"
else
    fail "GET /api/provisions returned invalid JSON"
fi

# Nonexistent provision → 404
PROV_404=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/provisions/999999999")
assert_http "$PROV_404" "404" "GET /api/provisions/999999999"

# Protected endpoint without auth → 401
SANDBOX_NOAUTH=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/sandboxes")
assert_http "$SANDBOX_NOAUTH" "401" "GET /api/sandboxes (no auth)"

# CORS preflight
CORS_RESP=$(curl -s -I -X OPTIONS "$API_URL/api/sandboxes" \
    -H "Origin: http://localhost:1338" \
    -H "Access-Control-Request-Method: GET" 2>&1)
if echo "$CORS_RESP" | grep -qi "access-control-allow-origin"; then
    pass "CORS preflight returns allow-origin header"
else
    fail "CORS headers missing"
fi

# ═════════════════════════════════════════════════════════════════════════════
# Section 3: Session Auth Flow
# ═════════════════════════════════════════════════════════════════════════════

section "3" "Session Auth"

# 3a: Request challenge
CHALLENGE=$(curl -s -X POST "$API_URL/api/auth/challenge")
NONCE=$(echo "$CHALLENGE" | jq -r '.nonce')
MESSAGE=$(echo "$CHALLENGE" | jq -r '.message')

if [ -n "$NONCE" ] && [ "$NONCE" != "null" ] && [ ${#NONCE} -eq 64 ]; then
    pass "POST /api/auth/challenge → nonce (${NONCE:0:16}...)"
else
    fail "Challenge nonce invalid: $NONCE"
fi

assert_contains "$MESSAGE" "$NONCE" "Challenge message contains nonce"

# 3b: Sign the message with EIP-191 (cast wallet sign does personal_sign)
SIGNATURE=$(cast wallet sign --private-key "$USER_KEY" "$MESSAGE" 2>/dev/null)
if [ -n "$SIGNATURE" ] && [ ${#SIGNATURE} -gt 10 ]; then
    pass "Message signed (${SIGNATURE:0:16}...)"
else
    fail "Failed to sign message"
fi

# 3c: Exchange for session token
SESSION_RESP=$(curl -s -X POST "$API_URL/api/auth/session" \
    -H "Content-Type: application/json" \
    -d "{\"nonce\":\"$NONCE\",\"signature\":\"$SIGNATURE\"}")
TOKEN=$(echo "$SESSION_RESP" | jq -r '.token // empty')
SESSION_ADDR=$(echo "$SESSION_RESP" | jq -r '.address // empty')

if [ -n "$TOKEN" ] && echo "$TOKEN" | grep -q "^v4.local."; then
    pass "Session token is PASETO v4 (${TOKEN:0:30}...)"
else
    fail "Invalid session token: ${TOKEN:0:50}"
fi

# Address comparison (case-insensitive)
EXPECTED_LOWER=$(echo "$USER_ADDR" | tr '[:upper:]' '[:lower:]')
GOT_LOWER=$(echo "$SESSION_ADDR" | tr '[:upper:]' '[:lower:]')
assert_eq "$GOT_LOWER" "$EXPECTED_LOWER" "Session address matches user"

# 3d: Use token to access protected endpoint
SANDBOX_LIST_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/sandboxes" \
    -H "Authorization: Bearer $TOKEN")
assert_http "$SANDBOX_LIST_CODE" "200" "GET /api/sandboxes (with valid token)"

# 3e: Error cases
# Invalid signature
CHALLENGE2=$(curl -s -X POST "$API_URL/api/auth/challenge")
NONCE2=$(echo "$CHALLENGE2" | jq -r '.nonce')
BAD_SIG_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$API_URL/api/auth/session" \
    -H "Content-Type: application/json" \
    -d "{\"nonce\":\"$NONCE2\",\"signature\":\"0xdeadbeef\"}")
assert_http "$BAD_SIG_CODE" "401" "Invalid signature rejected"

# Nonce replay (nonce2 was consumed above)
REPLAY_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$API_URL/api/auth/session" \
    -H "Content-Type: application/json" \
    -d "{\"nonce\":\"$NONCE2\",\"signature\":\"0xdeadbeef\"}")
assert_http "$REPLAY_CODE" "401" "Nonce replay rejected"

# Garbage token on protected endpoint
GARBAGE_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/sandboxes" \
    -H "Authorization: Bearer garbage-token-here")
assert_http "$GARBAGE_CODE" "401" "Garbage token rejected"

# Missing auth header
NO_AUTH_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/sandboxes")
assert_http "$NO_AUTH_CODE" "401" "Missing auth header rejected"

# ═════════════════════════════════════════════════════════════════════════════
# Section 4: Sandbox Lifecycle (EventDriven)
# ═════════════════════════════════════════════════════════════════════════════

if [ "${SKIP_LIFECYCLE:-}" = "1" ]; then
    section "4" "Sandbox Lifecycle (SKIPPED)"
    skip "Sandbox lifecycle (SKIP_LIFECYCLE=1)"
else
    section "4" "Sandbox Lifecycle"

    # Get job rate for sandbox_create (job 0) to know how much value to send
    CREATE_RATE=$(get_job_rate "$SANDBOX_BLUEPRINT_ID" 0)
    if [ "$CREATE_RATE" = "0" ] || [ -z "$CREATE_RATE" ]; then
        CREATE_RATE="1000000000000000" # fallback 1e15
    fi
    echo "  Using create rate: $CREATE_RATE wei"

    # 4a: Create sandbox
    # SandboxCreateRequest: (string name, string image, string stack, string agent_id,
    #   string env_json, string metadata_json, bool ssh, string ssh_key, bool web_term,
    #   uint64 max_life, uint64 idle, uint64 cpu, uint64 mem, uint64 disk, bool tee, uint8 tee_type)
    CREATE_ARGS=$(cast abi-encode \
        "f(string,string,string,string,string,string,bool,string,bool,uint64,uint64,uint64,uint64,uint64,bool,uint8)" \
        "e2e-sandbox" "agent-dev" "default" "default-agent" "{}" "{}" \
        false "" true \
        3600 900 2 2048 10 \
        false 0)

    SANDBOX_CALL_ID=$(submit_job "$SANDBOX_SERVICE_ID" 0 "$CREATE_ARGS" "$CREATE_RATE") || true
    if [ "$SANDBOX_CALL_ID" = "REVERT" ] || [ "$SANDBOX_CALL_ID" = "TX_FAIL" ]; then
        fail "sandbox_create submitJob failed ($SANDBOX_CALL_ID)"
        # Try to continue with error cases anyway
        SANDBOX_CREATED=false
    else
        pass "sandbox_create submitted (call_id=$SANDBOX_CALL_ID)"
        SANDBOX_CREATED=true
    fi

    SANDBOX_ID=""
    SIDECAR_URL=""

    if [ "$SANDBOX_CREATED" = "true" ]; then
        # Poll for provision to complete
        echo "  Waiting for provision (timeout ${TIMEOUT}s)..."
        PROVISION_RESULT=$(poll_provision "$SANDBOX_CALL_ID" "ready" "$TIMEOUT") || true

        if echo "$PROVISION_RESULT" | grep -q "TIMEOUT\|FAILED"; then
            fail "sandbox provision did not reach ready ($PROVISION_RESULT)"
        else
            SANDBOX_ID=$(echo "$PROVISION_RESULT" | jq -r '.sandbox_id // empty')
            SIDECAR_URL=$(echo "$PROVISION_RESULT" | jq -r '.sidecar_url // empty')
            if [ -n "$SANDBOX_ID" ] && [ "$SANDBOX_ID" != "null" ]; then
                pass "Sandbox provisioned: id=$SANDBOX_ID"
            else
                fail "Sandbox provision missing sandbox_id"
            fi
            if [ -n "$SIDECAR_URL" ] && [ "$SIDECAR_URL" != "null" ]; then
                pass "Sidecar URL: $SIDECAR_URL"
            else
                fail "Sandbox provision missing sidecar_url"
            fi
        fi

        # Verify sandbox appears in listing
        if [ -n "$TOKEN" ]; then
            SANDBOX_LIST=$(curl -s "$API_URL/api/sandboxes" -H "Authorization: Bearer $TOKEN")
            if echo "$SANDBOX_LIST" | jq -e ".sandboxes[] | select(.id == \"$SANDBOX_ID\")" > /dev/null 2>&1; then
                pass "Sandbox visible in GET /api/sandboxes"
            else
                # Try matching by name if id doesn't match
                if echo "$SANDBOX_LIST" | jq -e '.sandboxes[] | select(.name == "e2e-sandbox")' > /dev/null 2>&1; then
                    pass "Sandbox visible in GET /api/sandboxes (matched by name)"
                else
                    fail "Sandbox not found in listing"
                fi
            fi
        fi
    fi

    # 4b: Execute command via submitJob
    if [ -n "$SIDECAR_URL" ] && [ "$SIDECAR_URL" != "null" ]; then
        EXEC_RATE=$(get_job_rate "$SANDBOX_BLUEPRINT_ID" 5)
        if [ "$EXEC_RATE" = "0" ] || [ -z "$EXEC_RATE" ]; then
            EXEC_RATE="1000000000000000"
        fi

        # SandboxExecRequest: (string sidecar_url, string command, string cwd, string env_json, uint64 timeout_ms)
        EXEC_ARGS=$(cast abi-encode \
            "f(string,string,string,string,uint64)" \
            "$SIDECAR_URL" "echo e2e-exec-ok" "" "" 30000)

        EXEC_CALL_ID=$(submit_job "$SANDBOX_SERVICE_ID" 5 "$EXEC_ARGS" "$EXEC_RATE") || true
        if [ "$EXEC_CALL_ID" = "REVERT" ] || [ "$EXEC_CALL_ID" = "TX_FAIL" ]; then
            fail "sandbox_exec submitJob failed ($EXEC_CALL_ID)"
        else
            pass "sandbox_exec submitted (call_id=$EXEC_CALL_ID)"
            # Give operator time to process
            sleep 5
        fi
    else
        skip "sandbox_exec (no sidecar_url)"
    fi

    # 4c/4d/4e: Stop/Resume/Delete
    # These require the BSM's sandboxOperator[hash] mapping to be populated, which
    # only happens when onJobResult is called after the operator submits results
    # on-chain. In local dev, the TangleConsumer in the blueprint SDK silently fails
    # to post results, so onJobResult is never called and the mapping stays empty.
    # The BSM's onJobCall then reverts with SandboxNotFound.
    #
    # Full lifecycle coverage (stop → resume → delete) is tested in:
    #   - Solidity: contracts/test/AgentSandboxBlueprint.t.sol (test_fullLifecycle)
    #   - Rust e2e: ai-agent-sandbox-blueprint-lib/tests/anvil.rs (SIDECAR_E2E=1)
    skip "sandbox_stop (requires on-chain result submission — tested in anvil.rs + Solidity)"
    skip "sandbox_resume (requires on-chain result submission — tested in anvil.rs + Solidity)"
    skip "sandbox_delete (requires on-chain result submission — tested in anvil.rs + Solidity)"

    # 4f: Error cases

    # Stop nonexistent sandbox
    section "4f" "Sandbox Error Cases"
    BAD_STOP_ARGS=$(cast abi-encode "f(string)" "nonexistent-sandbox-id-12345")
    BAD_STOP_RATE=$(get_job_rate "$SANDBOX_BLUEPRINT_ID" 1)
    if [ "$BAD_STOP_RATE" = "0" ] || [ -z "$BAD_STOP_RATE" ]; then
        BAD_STOP_RATE="1000000000000000"
    fi
    BAD_STOP_RESULT=$(cast call "$TANGLE" \
        "submitJob(uint64,uint8,bytes)(uint64)" \
        "$SANDBOX_SERVICE_ID" 1 "$BAD_STOP_ARGS" \
        --from "$USER_ADDR" --rpc-url "$RPC_URL" --value "$BAD_STOP_RATE" 2>&1 || true)
    # BSM's onJobCall routes STOP via sandboxOperator[hash], which reverts with
    # SandboxNotFound for a sandbox that was never created on-chain.
    assert_reverts "$BAD_STOP_RESULT" "Stop nonexistent sandbox reverts on-chain"

    # submitJob with invalid job ID
    BAD_JOB_RESULT=$(cast call "$TANGLE" \
        "submitJob(uint64,uint8,bytes)(uint64)" \
        "$SANDBOX_SERVICE_ID" 99 "0x" \
        --from "$USER_ADDR" --rpc-url "$RPC_URL" --value "1000000000000000" 2>&1 || true)
    assert_reverts "$BAD_JOB_RESULT" "submitJob with invalid job ID=99"

    # submitJob with zero-length args for sandbox_create
    # BSM's onJobCall for CREATE only does _selectByCapacity (no input validation),
    # so this should succeed at the on-chain level. The operator will fail on decode.
    EMPTY_CREATE_RESULT=$(cast call "$TANGLE" \
        "submitJob(uint64,uint8,bytes)(uint64)" \
        "$SANDBOX_SERVICE_ID" 0 "0x" \
        --from "$USER_ADDR" --rpc-url "$RPC_URL" --value "$CREATE_RATE" 2>&1 || true)
    if echo "$EMPTY_CREATE_RESULT" | grep -qi "revert"; then
        fail "Empty args for sandbox_create unexpectedly reverted"
    else
        pass "Empty args for sandbox_create accepted (operator handles decode)"
    fi
fi

# ═════════════════════════════════════════════════════════════════════════════
# Section 5: Instance Lifecycle (Subscription)
# ═════════════════════════════════════════════════════════════════════════════

if [ "${SKIP_LIFECYCLE:-}" = "1" ] || [ "${SKIP_INSTANCE:-}" = "1" ]; then
    section "5" "Instance Lifecycle (SKIPPED)"
    skip "Instance lifecycle (SKIP_LIFECYCLE/SKIP_INSTANCE=1)"
else
    # Instance lifecycle requires a separate instance operator binary running.
    # Auto-detect: if no instance operator process is found, skip gracefully.
    if ! pgrep -f "ai-agent-instance-blueprint.*run" > /dev/null 2>&1; then
        section "5" "Instance Lifecycle (SKIPPED)"
        skip "Instance lifecycle (no instance operator running — start ai-agent-instance-blueprint)"
    else
    section "5" "Instance Lifecycle"

    # Instance services use Subscription pricing — no value required per-job.
    # But the user must still be a permitted caller.

    INST_USER_PERMITTED=$(cast call "$TANGLE" "isPermittedCaller(uint64,address)(bool)" "$INSTANCE_SERVICE_ID" "$USER_ADDR" --rpc-url "$RPC_URL" 2>/dev/null || echo "false")
    if [ "$INST_USER_PERMITTED" = "true" ]; then
        pass "User is permitted caller on instance service"
    else
        fail "User is NOT permitted caller on instance service"
        echo "  Skipping instance lifecycle tests"
        skip "Instance lifecycle (not permitted)"
    fi

    if [ "$INST_USER_PERMITTED" = "true" ]; then
        # 5a: Provision instance
        # ProvisionRequest: (string name, string image, string stack, string agent_id,
        #   string env_json, string metadata_json, bool ssh, string ssh_key, bool web_term,
        #   uint64 max_life, uint64 idle, uint64 cpu, uint64 mem, uint64 disk,
        #   string sidecar_token, bool tee, uint8 tee_type)
        INST_ARGS=$(cast abi-encode \
            "f(string,string,string,string,string,string,bool,string,bool,uint64,uint64,uint64,uint64,uint64,string,bool,uint8)" \
            "e2e-instance" "agent-dev" "default" "default-agent" "{}" "{}" \
            false "" true \
            3600 900 2 2048 10 \
            "" false 0)

        INST_CALL_ID=$(submit_job "$INSTANCE_SERVICE_ID" 0 "$INST_ARGS" 0) || true
        if [ "$INST_CALL_ID" = "REVERT" ] || [ "$INST_CALL_ID" = "TX_FAIL" ]; then
            fail "instance_provision submitJob failed ($INST_CALL_ID)"
        else
            pass "instance_provision submitted (call_id=$INST_CALL_ID)"

            # Wait for provision
            echo "  Waiting for instance provision (timeout ${TIMEOUT}s)..."
            INST_PROV_RESULT=$(poll_provision "$INST_CALL_ID" "ready" "$TIMEOUT") || true

            if echo "$INST_PROV_RESULT" | grep -q "TIMEOUT\|FAILED"; then
                fail "instance provision did not reach ready ($INST_PROV_RESULT)"
            else
                INST_SANDBOX_ID=$(echo "$INST_PROV_RESULT" | jq -r '.sandbox_id // empty')
                INST_SIDECAR_URL=$(echo "$INST_PROV_RESULT" | jq -r '.sidecar_url // empty')
                if [ -n "$INST_SANDBOX_ID" ] && [ "$INST_SANDBOX_ID" != "null" ]; then
                    pass "Instance provisioned: id=$INST_SANDBOX_ID"
                else
                    fail "Instance provision missing sandbox_id"
                fi
            fi
        fi

        # 5b: Exec on instance (job=1)
        # Instance ExecRequest uses a simpler struct since the instance is singleton-scoped.
        # Check what the instance exec ABI looks like.
        if [ -n "${INST_SIDECAR_URL:-}" ] && [ "$INST_SIDECAR_URL" != "null" ]; then
            # Instance exec: (string command, string cwd, string env_json, uint64 timeout_ms)
            # Note: instance exec doesn't need sidecar_url — it's singleton-scoped
            INST_EXEC_ARGS=$(cast abi-encode \
                "f(string,string,string,uint64)" \
                "echo instance-e2e-ok" "" "" 30000)

            INST_EXEC_CID=$(submit_job "$INSTANCE_SERVICE_ID" 1 "$INST_EXEC_ARGS" 0) || true
            if [ "$INST_EXEC_CID" = "REVERT" ] || [ "$INST_EXEC_CID" = "TX_FAIL" ]; then
                fail "instance_exec submitJob failed ($INST_EXEC_CID)"
            else
                pass "instance_exec submitted (call_id=$INST_EXEC_CID)"
                sleep 5
            fi
        else
            skip "instance_exec (no sidecar_url)"
        fi

        # 5c: Deprovision (job=7)
        # DeprovisionRequest is just a JsonResponse: (string json)
        DEPROV_ARGS=$(cast abi-encode "f(string)" '{"reason":"e2e-cleanup"}')
        DEPROV_CID=$(submit_job "$INSTANCE_SERVICE_ID" 7 "$DEPROV_ARGS" 0) || true
        if [ "$DEPROV_CID" = "REVERT" ] || [ "$DEPROV_CID" = "TX_FAIL" ]; then
            fail "instance_deprovision submitJob failed ($DEPROV_CID)"
        else
            pass "instance_deprovision submitted (call_id=$DEPROV_CID)"
            sleep 5
        fi
    fi
    fi  # end pgrep instance operator check
fi

# ═════════════════════════════════════════════════════════════════════════════
# Section 6: Summary
# ═════════════════════════════════════════════════════════════════════════════

ELAPSED=$(($(date +%s) - START_TIME))
echo ""
echo "=========================================="
echo -e "  Results: ${GREEN}$PASS passed${NC}, ${RED}$FAIL failed${NC}, ${YELLOW}$SKIP skipped${NC}"
echo "  Total:   $TOTAL tests in ${ELAPSED}s"
echo "=========================================="

if [ "$FAIL" -gt 0 ]; then
    exit 1
fi
